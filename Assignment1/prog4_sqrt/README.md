

1. SIMD加速4倍，`multi-core parallelization`加速9-10倍。

2. 将`values`数组中的所有值设为2.999，这样选的原因可以从两个较大解释：

   - 首先，我们确保了所有值一样，这会使得在每一次SIMD运算中所有`lanes`都被利用，即`Coherent Execution`
   - 其次，我们会发现如果将`values[i]`全部设置为更小的数字会导致加速比降低，这是因为除了多线程本身的运算外，函数的执行还有额外的开销，我们要尽可能的提高多线程运算在函数执行过程中的时间占比，所以将`values[i]`设置为更大的数会提高加速比。

   而对于`multi-core speedup`，没有提升，因为我们先前的改动仅针对每个核内部的操作有效，并不涉及多核执行过程。

3. 将`values`数组中的除了8的整数位上的值全部设置为1，被8整除的位置上的值设定为2.999，效率降低的原因也可以从两个角度描述：

   - 将被8整除的位置上的数值设定为2.999的原因是最大程度的减少`Coherent Execution`，让每次8宽的SIMD指令中只有一个`lane`被利用，其余的`lane`全部在做无用功。

   - 将除了8的整数位上的值全部设置为1的原因和上一问题中的选择1的原因一样，最大程度的减小并行计算的加速比提高程度，同时也是在最大化每次SIMD中唯一一个被利用的`lane`的对并行效率的缩减程度。

4. 由于这部分我使用了`gdb`对代码进行调试，而在一开始的`Makefile`中并没有告诉编译器生成调试需要的符号表，所以我们需要在对应的`CXXFLAGS`中加入`-g`(有的平台可能还需要在`LDFLAGS`中加入`-g`选项)

   这里比较麻烦的点在于`while`循环的向量化上：首先通过原本`while`循环条件上的比较制作一个`mask`，再使用`_mm256_movemask_ps`函数将该向量转化成`int`便于判定其中是否存在1。而先前制作的`mask`则可以被利用到循环内部的指令中，即只在`active lanes`上做操作：

   ```cpp
   guess = _mm256_blendv_ps(guess, newguess, cmpres);
   ```

   这样一来，如果`guess`在对应的`lanes`上没有发生改变，接下来的`error`在对应的位置也就不会改变，以此类推。

   需要注意的是，由于在分配数组的时候我们并没有保证内存对齐，所以在对内存进行操作时，应该使用`loadu/storeu`指令。
